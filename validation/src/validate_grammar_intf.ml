open! Base

module type S = sig
  type t [@@deriving quickcheck, sexp, sexp_grammar]
end

module type S1 = sig
  type _ t [@@deriving quickcheck, sexp, sexp_grammar]
end

module type With_grammar = sig
  type t [@@deriving sexp_grammar]
end

module type Validate_grammar = sig
  module type S = S
  module type S1 = S1
  module type With_grammar = With_grammar

  (** Pretty-prints a grammar. *)
  val show_grammar : (module With_grammar) -> unit

  (** Validates a grammar.

      First, calls [show_grammar].

      Then, checks that [t_sexp_grammar] accepts all sexps generated by
      [sexp_of_t].

      Also checks that [t_of_sexp] rejects all sexps rejected by [t_sexp_grammar]. Skips
      this if [t_sexp_grammar] amounts to [Any _], to avoid an infinite loop trying to
      find rejected sexps.

      Produces an [Or_error] rather than printing crs to allow testing deliberate
      failures. *)
  val validate_grammar : ?test_count:int -> (module S) -> unit Or_error.t

  (** Like [validate_grammar], for polymorphic grammars. Instantiates the given grammar
      with a type whose grammar is [Any "A"], to make it easy to see where the argument
      shows up. *)
  val validate_grammar_poly1 : ?test_count:int -> (module S1) -> unit Or_error.t

  (** [spot_check_grammar t_sexp_grammar t_of_sexp] returns a function to check that
      [t_sexp_grammar] agrees with [t_of_sexp] as to whether an example sexp is valid.

      It pays to apply [spot_check_grammar] to the grammar once and then check multiple
      sexps with the resulting function. The first application does nontrivial work to
      prepare the sexp grammar. *)
  val spot_check_grammar
    :  [%sexp_grammar: 'a]
    -> [%of_sexp: 'a]
    -> (Sexp.t -> unit Or_error.t) Staged.t
end
